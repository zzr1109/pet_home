/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	const GMapsApi = __webpack_require__(1);



	class GMap {

	  constructor(configObject) {

	    this.groupElements = [];
	    this.groups = {};
	    this.groupOrder = [];
	    this.mapInstance = {};
	    this.activeGroup = 0;
	    this.focusMarker = {};
	    this.infoWindow = false;


	    if (configObject.querySelector == null) {
	      throw new Error("querySelector is not set.");
	    }

	    if (configObject.apiKey == null) {
	      throw new Error("apiKey is not set.");
	    }

	    if (configObject.mapConfig.center == null &&
	      configObject.mapConfig.center.lat == null &&
	      configObject.mapConfig.center.long == null
	    ) {
	      throw new Error("center.lat & center.long is not set.");
	    }


	    this.configObject = configObject;

	    // groupBy (property | nested array)


	    this.init()
	    .then((mapsApi) => {
	      return this.processMapGroups(mapsApi);
	    })
	    .catch(err => {
	      console.log(err);
	    });

	  }


	  init() {

	    return new Promise((resolve) => {

	      GMapsApi.load(google => {

	        let mapsApi = google.maps;
	        let mountElement = document.querySelector(this.configObject.querySelector);
	        let mapConfig = this.configObject.mapConfig;
	        let mapOptions = {
	          zoom: mapConfig.zoom,
	          center: new mapsApi.LatLng(mapConfig.center.lat, mapConfig.center.long)
	        };

	        this.mapInstance = new mapsApi.Map(mountElement, mapOptions);

	        this.infoWindow = new mapsApi.InfoWindow({
	            content: 'loading'
	        });

	        resolve(mapsApi);
	      });

	    });
	  }

	  processMapGroups(mapsApi) {

	    return new Promise((resolve) => {

	      if (this.configObject.focusElement) {
	        let focusElement = document.querySelector(this.configObject.focusElement);
	        let $focusElement = $(focusElement);
	        let focusPoint = $focusElement.data("marker");
	        let focusMarkerIcon = $focusElement.data("marker-icon");
	        this.focusMarker = this.createMarker(mapsApi, focusPoint, focusMarkerIcon);
	      }





	      this.groupElements = document.querySelectorAll(this.configObject.groupElements);

	      for (var i = 0; i < this.groupElements.length; ++i) {

	        let element = this.groupElements[i];
	        let $element = $(element);
	        let points = $element.data("markers");
	        let id = parseInt($element.data("id"));
	        let markerIcon = $element.data("marker-icon");

	        let markers = [];

	        points.forEach((point) => {
	          markers.push(this.createMarker(mapsApi, point, markerIcon, false));
	        });


	        this.groups[element.dataset.id] = {
	          id: id,
	          markers: markers,
	          visible: false
	        };

	        this.groupOrder.push(id);

	        this.addEvent(mapsApi, element, id);

	      }

	      if (this.configObject.firstGroupOn) {
	        let firstGroupkey = this.groupOrder.shift();
	        let bounds = new mapsApi.LatLngBounds();
	        this.markerVisible(mapsApi, this.groups[firstGroupkey].markers, true, bounds);
	        this.groups[firstGroupkey].visible = true;
	        this.activeGroup = firstGroupkey;
	        this.groupOrder = this.groupOrder.unshift(firstGroupkey);
	      }

	      resolve(mapsApi);

	    });
	  }


	  createMarker(mapsApi, point, markerIcon, setVisible = true) {
	    let lat = parseFloat(point.latitude);
	    let Lng = parseFloat(point.longitude);

	    let position = new mapsApi.LatLng(lat, Lng);

	    let marker = new mapsApi.Marker({
	      position: position,
	      map: this.mapInstance,
	      icon: markerIcon
	    });

	    var infoContent = `<div class="mapPopUp">`;
	    infoContent += `<p>${point.title}</p>`;

	    //let fromDirection = `http://maps.google.com/maps?f=d&hl=en&geocode=&time=&date=&ttype=&saddr=${lat},${Lng}`;
	    //<a target="_BLANK" href="${fromDirection}">From</a> -
	    let toDirection = `http://maps.google.com/maps?f=d&hl=en&geocode=&time=&date=&ttype=&saddr=&daddr=${lat},${Lng}`;
	    infoContent += `<p><a target="_BLANK" href="${toDirection}" style="color: #000;">Directions</a></p>`;

	    if (point.description !== "" && point.description !== null) {
	      infoContent += `<p>${point.description}</p>`;
	    }

	    infoContent += `</div>`;

	    mapsApi.event.addListener(marker, 'click', () => {
	        this.infoWindow.setContent(infoContent);
	        this.infoWindow.open(this.mapInstance, marker);
	    });

	    let bounds = new mapsApi.LatLngBounds();

	    this.markerVisible(mapsApi, marker, setVisible, bounds);
	    return marker;

	  }


	  markerVisible(mapsApi, markers, setVisible, bounds = false) {

	    this.infoWindow.close();

	    if (Array.isArray(markers)) {

	      markers.forEach((element) => {
	        if (bounds) {
	          bounds.extend(element.getPosition());
	        }
	        element.setVisible(setVisible);
	      });

	      if (bounds) {
	        bounds.extend(this.focusMarker.getPosition());
	        this.mapInstance.fitBounds(bounds);
	      }
	    } else {
	      markers.setVisible(setVisible);
	    }
	  }


	  addEvent(mapsApi, element, id){

	    element.addEventListener("click", this.eventHandler(mapsApi, id));
	    element.addEventListener("touchstart", this.eventHandler(mapsApi, id));
	  }

	  eventHandler(mapsApi, id) {
	      return (event) => {
	          this.menuEventActions(event, mapsApi, id);
	      };
	  }

	  menuEventActions(event, mapsApi, id) {
	    event.preventDefault();

	    if (this.activeGroup !== id) {
	      this.markerVisible(mapsApi, this.groups[this.activeGroup].markers, false);
	      this.groups[this.activeGroup].visible = false;
	    }

	    this.activeGroup = id;
	    let visible = (this.groups[id].visible) ? false : true;

	    let bounds = (visible) ? new mapsApi.LatLngBounds() : false;
	    this.markerVisible(mapsApi, this.groups[id].markers, visible, bounds);

	  }

	}




	module.exports = GMap;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(root, factory) {

		if (root === null) {
			throw new Error('Google-maps package can be used only in browser');
		}

		if (true) {
			!(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (typeof exports === 'object') {
			module.exports = factory();
		} else {
			root.GoogleMapsLoader = factory();
		}

	})(typeof window !== 'undefined' ? window : null, function() {


		'use strict';


		var googleVersion = '3.18';

		var script = null;

		var google = null;

		var loading = false;

		var callbacks = [];

		var onLoadEvents = [];

		var originalCreateLoaderMethod = null;


		var GoogleMapsLoader = {};


		GoogleMapsLoader.URL = 'https://maps.googleapis.com/maps/api/js';

		GoogleMapsLoader.KEY = null;

		GoogleMapsLoader.LIBRARIES = [];

		GoogleMapsLoader.CLIENT = null;

		GoogleMapsLoader.CHANNEL = null;

		GoogleMapsLoader.SENSOR = null;

		GoogleMapsLoader.VERSION = googleVersion;

		GoogleMapsLoader.WINDOW_CALLBACK_NAME = '__google_maps_api_provider_initializator__';


		GoogleMapsLoader._googleMockApiObject = {};


		GoogleMapsLoader.load = function(fn) {
			if (google === null) {
				if (loading === true) {
					if (fn) {
						callbacks.push(fn);
					}
				} else {
					loading = true;

					window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] = function() {
						ready(fn);
					};

					GoogleMapsLoader.createLoader();
				}
			} else if (fn) {
				fn(google);
			}

			var promiseError = function() {
				throw new Error('Using promises is not supported anymore. Please take a look in new documentation and use callback instead.');
			};

			return {
				then: promiseError,
				catch: promiseError,
				fail: promiseError
			};
		};


		GoogleMapsLoader.createLoader = function() {
			script = document.createElement('script');
			script.type = 'text/javascript';
			script.src = GoogleMapsLoader.createUrl();

			document.body.appendChild(script);
		};


		GoogleMapsLoader.isLoaded = function() {
			return google !== null;
		};


		GoogleMapsLoader.createUrl = function() {
			var url = GoogleMapsLoader.URL;

			url += '?callback=' + GoogleMapsLoader.WINDOW_CALLBACK_NAME;

			url += '&sensor=' + ((GoogleMapsLoader.SENSOR === true || GoogleMapsLoader.SENSOR === 'true') ? 'true' : 'false');

			if (GoogleMapsLoader.KEY) {
				url += '&key=' + GoogleMapsLoader.KEY;
			}

			if (GoogleMapsLoader.LIBRARIES.length > 0) {
				url += '&libraries=' + GoogleMapsLoader.LIBRARIES.join(',');
			}

			if (GoogleMapsLoader.CLIENT) {
				url += '&client=' + GoogleMapsLoader.CLIENT + '&v=' + GoogleMapsLoader.VERSION;
			}

			if (GoogleMapsLoader.CHANNEL) {
				url += '&channel=' + GoogleMapsLoader.CHANNEL;
			}

			return url;
		};


		GoogleMapsLoader.release = function(fn) {
			var release = function() {
				GoogleMapsLoader.KEY = null;
				GoogleMapsLoader.LIBRARIES = [];
				GoogleMapsLoader.CLIENT = null;
				GoogleMapsLoader.SENSOR = false;
				GoogleMapsLoader.VERSION = googleVersion;

				google = null;
				loading = false;
				callbacks = [];
				onLoadEvents = [];

				if (typeof window.google !== 'undefined') {
					delete window.google;
				}

				if (typeof window[GoogleMapsLoader.WINDOW_CALLBACK_NAME] !== 'undefined') {
					delete window[GoogleMapsLoader.WINDOW_CALLBACK_NAME];
				}

				if (originalCreateLoaderMethod !== null) {
					GoogleMapsLoader.createLoader = originalCreateLoaderMethod;
					originalCreateLoaderMethod = null;
				}

				if (script !== null) {
					script.parentElement.removeChild(script);
					script = null;
				}

				fn();
			};

			if (loading) {
				GoogleMapsLoader.load(function() {
					release();
				});
			} else {
				release();
			}
		};


		GoogleMapsLoader.onLoad = function(fn) {
			onLoadEvents.push(fn);
		};


		GoogleMapsLoader.makeMock = function() {
			originalCreateLoaderMethod = GoogleMapsLoader.createLoader;

			GoogleMapsLoader.createLoader = function() {
				window.google = GoogleMapsLoader._googleMockApiObject;
				window[GoogleMapsLoader.WINDOW_CALLBACK_NAME]();
			};
		};


		var ready = function(fn) {
			var i;

			loading = false;

			if (google === null) {
				google = window.google;
			}

			for (i = 0; i < onLoadEvents.length; i++) {
				onLoadEvents[i](google);
			}

			if (fn) {
				fn(google);
			}

			for (i = 0; i < callbacks.length; i++) {
				callbacks[i](google);
			}

			callbacks = [];
		};


		return GoogleMapsLoader;

	});


/***/ }
/******/ ]);